// Generated by CoffeeScript 1.6.2
(function() {
  var Client, EventEmitter, SocketRouter, Url, hooks, mdns, net, socket, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  socket = require("../socket");

  SocketRouter = socket.Router;

  Url = require("url");

  net = require("net");

  hooks = require("hooks");

  mdns = require("mdns");

  _ = require("underscore");

  EventEmitter = require("events").EventEmitter;

  Client = (function(_super) {
    __extends(Client, _super);

    /*
    */


    function Client() {
      this._onGetConnection = __bind(this._onGetConnection, this);
      this._onConnected = __bind(this._onConnected, this);
      this._onError = __bind(this._onError, this);
      this._reconnect = __bind(this._reconnect, this);      this._setupHooks();
    }

    /*
    */


    Client.prototype.connect = function(options) {
      var cc, hostParts, proxyParts;

      this.options = options;
      if (!~options.server.indexOf("://")) {
        options.server = "http://" + options.server;
      }
      if (!~options.proxy.indexOf("://")) {
        options.proxy = "http://" + options.proxy;
      }
      this.hostParts = hostParts = Url.parse(options.server);
      this.proxyParts = proxyParts = Url.parse(options.proxy);
      console.log("connecting to server " + options.server);
      this._chunnelConnection = cc = socket.connect(hostParts.port, hostParts.hostname);
      cc.send("client", {
        domain: options.domain,
        password: options.password,
        username: options.username
      });
      cc.route({
        error: this._onError,
        success: this._onConnected,
        getConnection: this._onGetConnection
      });
      cc.connection.on("end", this._reconnect);
      cc.connection.on("error", this._reconnect);
      return this;
    };

    /*
    */


    Client.prototype._reconnect = function() {
      var _this = this;

      console.log("chunnel server has disconnected, reconnecting");
      this._cid = void 0;
      this._secret = void 0;
      this._connected = false;
      return setTimeout((function() {
        return _this.connect(_this.options);
      }), 2000);
    };

    /*
    */


    Client.prototype._onError = function(err) {
      return console.error(err.message);
    };

    /*
    */


    Client.prototype._onConnected = function(result) {
      if (this._connected) {
        return;
      }
      this._connected = true;
      this._cid = result.cid;
      this._secret = result.secret;
      console.log("tunnel \"" + this.options.proxy + "\" is now accessible via \"" + this.options.domain + "\" on \"" + this.options.server + "\"");
      return this.emit("connected");
    };

    /*
    */


    Client.prototype._onGetConnection = function() {
      var c, c2;

      console.log("creating http connection");
      c2 = net.connect(Number(this.proxyParts.port || 80), this.proxyParts.hostname);
      c = socket.connect(Number(this.hostParts.port), this.hostParts.hostname);
      c.send("connection", {
        cid: this._cid,
        secret: this._secret
      });
      c2.pipe(c.connection);
      return c.connection.pipe(c2);
    };

    /*
    */


    Client.prototype._setupHooks = function() {
      _.extend(this, hooks);
      this.hook("connect", this.connect);
      return this.pre("connect", function(next, options) {
        var browser;

        if (options.server.substr(0, 1) !== "@") {
          return next();
        }
        console.log("waiting for local server %s", options.server);
        browser = mdns.createBrowser(mdns.tcp("chunnel"));
        browser.on("serviceUp", function(service) {
          if (service.name === options.server.substr(1)) {
            options.server = "" + service.addresses[0] + ":" + service.port;
            browser.stop();
            return next();
          }
        });
        return browser.start();
      });
    };

    return Client;

  })(EventEmitter);

  exports.connect = function(options, callback) {
    var client;

    client = new Client();
    client.connect(options, callback);
    return client;
  };

}).call(this);
