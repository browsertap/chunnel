// Generated by CoffeeScript 1.6.2
(function() {
  var EventEmitter, HttpServer, net,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  net = require("net");

  EventEmitter = require("events").EventEmitter;

  HttpServer = (function(_super) {
    __extends(HttpServer, _super);

    /*
    */


    function HttpServer() {
      this._onHttpClient = __bind(this._onHttpClient, this);      HttpServer.__super__.constructor.call(this);
      this._clients = {};
    }

    /*
    */


    HttpServer.prototype.listen = function(port) {
      var _this = this;

      this.port = port;
      this._server = net.createServer(this._onHttpClient).listen(port);
      return this._server.on("error", function(err) {
        _this._server = void 0;
        return _this.close(new Error("cannot open HTTP server: " + err.message));
      });
    };

    /*
    */


    HttpServer.prototype.hasClient = function(domain) {
      return !this._clients[domain];
    };

    /*
    */


    HttpServer.prototype.close = function(err) {
      var domain, _ref;

      if (this._closed) {
        return;
      }
      this._closed = true;
      if ((_ref = this._server) != null) {
        _ref.close();
      }
      for (domain in this._clients) {
        this._clients[domain].socket.error(err || new Error("http server has closed"));
        this._clients[domain].socket.close();
      }
      this._clients = {};
      return this.emit("close");
    };

    /*
    */


    HttpServer.prototype.addClient = function(domain, client) {
      var _this = this;

      this._clients[domain] = client;
      return client.once("close", function() {
        delete _this._clients[domain];
        if (!Object.keys(_this._clients).length) {
          return _this.close();
        }
      });
    };

    /*
    */


    HttpServer.prototype._onHttpClient = function(con) {
      var onErr,
        _this = this;

      onErr = function(err) {
        console.error("http error: " + ((err != null ? err.message : void 0) || "Unknown"));
        con.write("Not Found: " + ((err != null ? err.message : void 0) || "Unknown"));
        return con.end();
      };
      return con.once("data", function(h) {
        var client, host, hosts;

        con.pause();
        hosts = String(h).match(/host:\s+([^\r]+)/i);
        if (!hosts) {
          return onErr(new Error("host not found in HTTP headers"));
        }
        host = hosts[1].split(":").shift();
        client = _this._clients[host];
        if (!client) {
          return onErr(new Error("tunnel \"" + host + "\" not found"));
        }
        console.log("proxy " + host + ":" + _this.port);
        return client.getConnection(function(e, c) {
          if (e != null) {
            return onErr(e);
          }
          con.pipe(c);
          c.pipe(con);
          c.write(h);
          return con.resume();
        });
      });
    };

    return HttpServer;

  })(EventEmitter);

  module.exports = HttpServer;

}).call(this);
